// This file is automatically generated. Do not edit.
// To update this file, run `make codegen` (assumes that `info` repository is cloned in the same parent directory).
// Template: codegen/content.tmpl
// Schema source: https://github.com/alsosee/info/blob/main/_finder/schema.yml
package structs

import (
	{{- if .HashIDs }}
	"crypto/sha1"
	{{- end }}
	"fmt"
	"path/filepath"
	{{- if not .HashIDs }}
	"regexp"
	{{- end }}
	"strings"
	"time"
)

type Column struct {
	Name  string // used to lookup property in search hits response
	Title string // used for column name in UI
	Type  string // used to conditionally convert "duration" value from search hits response into human readable format
}

var ColumnsList = []Column{
	{{- range .Content.Properties }}
	{{- if .Column }}
	{
		Name: "{{ .Name }}",
		Title: "{{ columnTitle . }}",
		Type: "{{ .Type }}",
	},
	{{- end }}
	{{- end }}
}

// Content represents the content of a file.
type Content struct {
	ID                string `yaml:"-"`                   // used by Search
	Source            string `yaml:"-"`                   // path to the file
	SourceNoExtention string `yaml:"-"`                   // path to the file without extention
	HTML              string `yaml:"-" json:",omitempty"` // for Markdown files

	{{- range .Content.Properties }}
	{{ if eq .Meta "name" }}Name{{ else }}{{ titleCase .Name }}{{ end }} {{ fieldType . }} `yaml:"{{ .Name }},omitempty" json:"{{ .Name }},omitempty"`
	{{- end }}

	// unknown fields are stored in the Extra map
	Extra map[string]interface{} `yaml:",inline" json:",omitempty"`

	// fields populated by the generator
	Awards               []Award `yaml:"-" json:",omitempty"`
	EditorsAwards        []Award `yaml:"-" json:",omitempty"`
	WritersAwards        []Award `yaml:"-" json:",omitempty"`
	DirectorsAwards      []Award `yaml:"-" json:",omitempty"`
	CinematographyAwards []Award `yaml:"-" json:",omitempty"`
	MusicAwards          []Award `yaml:"-" json:",omitempty"`
	ScreenplayAwards     []Award `yaml:"-" json:",omitempty"`
}

// GenerateID generates an ID for the content.
// Used for identifying the content in connections and search.
func (c *Content) GenerateID() string {
	if c.ID != "" {
		return c.ID
	}

	c.SourceNoExtention = removeFileExtention(c.Source)

	{{- if .HashIDs }}
	c.ID = hashID(c.SourceNoExtention)
	{{- else }}
	c.ID = formatID(c.SourceNoExtention)
	{{- end }}

	return c.ID
}

// Type return a type of the content in singular form
// (e.g. "person" for "People", "book" for "Books", etc.)
// it used to add an additional context to reference link
// when current page and the reference have the same name
func (c Content) Type() string {
	// get first part of the Source path
	// (e.g. "People" or "Book")
	root := pathType(c.Source)
	switch root {
	{{- range $rootType := .RootTypes }}
	case "{{ .Path }}":
		return "{{ .Type }}"
	{{- end }}
	default:
		return strings.ToLower(root)
	}
}

// Header returns a string to be displayed in the header of the content.
// Title is used by default, Name is a fallback.
func (c Content) Header() string {
	{{- range .Content.Properties }}
	{{- if or (eq .Name "title") (eq .Alias "title") }}
	if c.{{ titleCase .Name }} != "" {
		return c.{{ titleCase .Name }}
	}
	{{- end }}
	{{- end }}

	{{- range .Content.Properties }}
	{{- if or (eq .Name "name") (eq .Alias "name") }}
	return c.{{ titleCase .Name }}
	{{- end }}
	{{- end }}
}

func (c *Content) SetName(name string) {
	{{- range .Content.Properties }}
	{{- if or (eq .Name "name") (eq .Alias "name") }}
	c.{{ titleCase .Name }} = name
	{{- end }}
	{{- end }}
}

func (c Content) GetName() string {
	{{- range .Content.Properties }}
	{{- if or (eq .Name "name") (eq .Alias "name") }}
	return c.{{ titleCase .Name }}
	{{- end }}
	{{- end }}
}

// Columns defines the columns to be displayed in the List view.
func (c Content) Columns() map[string]string {
	return map[string]string{
	{{- range .Content.Properties }}
		{{- if .Column }}
		"{{ columnTitle . }}": {{ columnValue . }},
		{{- end }}
	{{- end }}
	}
}

// Connections returns a list of connections to other content.
func (c Content) Connections() []Connection {
	var connections []Connection
	{{ template "connections" dict
		"Content" .Content
		"Prefix" "c" }}
	return connections
}
{{- range $key, $content := .Extra }}

type {{ titleCase $key }} struct {
{{- range $content.Properties }}
	{{ titleCase .Name }} {{ fieldType . }} `yaml:"{{ .Name }},omitempty" json:"{{ .Name }},omitempty"`
{{- end }}

	// unknown fields are stored in the Extra map
	Extra map[string]interface{} `yaml:",inline" json:",omitempty"`
}
{{- end }}

// AddMedia populates the Image field with a Media object.
func (c *Content) AddMedia(getImage func(string) *Media) {
	{{- template "media" dict
		"Content" .Content
		"Prefix" "c" }}
}

func IsPerson(path string) bool {
	{{- range .RootTypes }}
	{{- if or (eq .Path "People") (eq .Meta "People") }}
	return pathType(path) == "{{ .Path }}"
	{{- end }}
	{{- end }}
}

func PersonPrefix() string {
    {{- range .RootTypes }}
	{{- if or (eq .Path "People") (eq .Meta "People") }}
	return "{{ .Path }}"
    {{- end }}
    {{- end }}
}

func ContentFieldName(field string) string {
	{{- $nameAlias := "" }}
	{{- $titleAlias := "" }}
	{{- range .Content.Properties }}
	{{- if (eq .Alias "name") }}
	{{- $nameAlias = .Name }}
	{{- end }}
	{{- if (eq .Alias "title") }}
	{{- $titleAlias = .Name }}
	{{- end }}
	{{- end }}

	{{- if $nameAlias }}
	if field == "name" {
		return "{{ $nameAlias }}"
	}
	{{- end }}

	{{- if $titleAlias }}
	if field == "title" {
		return "{{ $titleAlias }}"
	}
	{{- end }}
	return field
}

func length(a time.Duration) string {
	if a == 0 {
		return ""
	}

	if a < time.Hour {
		// format duration as "2m"
		return fmt.Sprintf("%dm", int(a.Minutes()))
	}

	// format duration as "1h 2m"
	return fmt.Sprintf("%dh %dm", int(a.Hours()), int(a.Minutes())%60)
}

func pathType(path string) string {
	return strings.Split(path, string(filepath.Separator))[0]
}

func removeFileExtention(path string) string {
	withoutExt := path[:len(path)-len(filepath.Ext(path))]
	if withoutExt != "" {
		return withoutExt
	}
	return path
}

{{- if .HashIDs }}

func hashID(id string) string {
	return fmt.Sprintf("%x", sha1.Sum([]byte(id)))
}
{{- else }}

var reNonID = regexp.MustCompile("[^a-zA-Z0-9-_]")

// formatID formats an ID for MeiliSearch.
// A document identifier can be of type integer or string,
// only composed of alphanumeric characters (a-z A-Z 0-9), hyphens (-) and underscores (_).
func formatID(id string) string {
	return reNonID.ReplaceAllString(id, "_")
}
{{- end }}
