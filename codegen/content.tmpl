// This file is automatically generated. Do not edit.
// To update this file, run `make codegen` (assumes that `info` repository is cloned in the same parent directory).
// Template: codegen/content.tmpl
// Schema source: https://github.com/alsosee/info/blob/main/_finder/schema.yml
package structs

import (
	"fmt"
	"path/filepath"
	"strings"
	"time"
)

// Content represents the content of a file.
type Content struct {
	ID     string `yaml:"-"`                   // used by Search
	Source string `yaml:"-"`                   // path to the file
	HTML   string `yaml:"-" json:",omitempty"` // for Markdown files

	{{- range .Content.Properties }}
	{{ titleCase .Name }} {{ fieldType . $.Content.RootTypes }} `yaml:"{{ .Name }},omitempty" json:"{{ .Name }},omitempty"`
	{{- end }}

	// unknown fields are stored in the Extra map
	Extra map[string]interface{} `yaml:",inline" json:",omitempty"`

	// fields populated by the generator
	Image                *Media  `yaml:"-" json:",omitempty"`
	Awards               []Award `yaml:"-" json:",omitempty"`
	EditorsAwards        []Award `yaml:"-" json:",omitempty"`
	WritersAwards        []Award `yaml:"-" json:",omitempty"`
	DirectorsAwards      []Award `yaml:"-" json:",omitempty"`
	CinematographyAwards []Award `yaml:"-" json:",omitempty"`
	MusicAwards          []Award `yaml:"-" json:",omitempty"`
	ScreenplayAwards     []Award `yaml:"-" json:",omitempty"`
}

// GenerateID generates an ID for the content.
// Used for identifying the content in connections and search.
func (c Content) GenerateID() string {
	if c.ID != "" {
		return c.ID
	}

	c.ID = removeFileExtention(c.Source)
	return c.ID
}

// Type return a type of the content in singular form
// (e.g. "person" for "People", "book" for "Books", etc.)
// it used to add an additional context to reference link
// when current page and the reference have the same name
func (c Content) Type() string {
	// get first part of the Source path
	// (e.g. "People" or "Book")
	root := pathType(c.Source)
	switch root {
	{{- range $rootType := .Content.RootTypes }}
	case "{{ .Path }}":
		return "{{ .Type }}"
	{{- end }}
	default:
		return strings.ToLower(root)
	}
}

// Columns defines the columns to be displayed in the List view.
func (c Content) Columns() map[string]string {
	return map[string]string{
	{{- range .Content.Properties }}
		{{- if .Column }}
		"{{ columnTitle . }}": {{ columnValue . $.Content.RootTypes }},
		{{- end }}
	{{- end }}
	}
}

// Connections returns a list of connections to other content.
func (c Content) Connections() []Connection {
	var connections []Connection
	{{- range .Content.Properties }}
	{{- $path := rootTypePath .Type $.Content.RootTypes }}
	{{- if eq .Type "reference" }}
	if c.{{ titleCase .Name }} != nil {
		connections = append(connections, Connection{
			To: c.{{ titleCase .Name }}.Path,
			Label: "{{ .Label }}",
			Meta: "{{ .Meta }}",
		})
	}
	{{- else if $path }}
	if c.{{ titleCase .Name }} != "" {
		connections = append(connections, Connection{
			To: "{{ $path }}/" + c.{{ titleCase .Name }},
			Label: "{{ if .Label }}{{ .Label }}{{ else }}{{ titleCase .Name }}{{ end }}",
		})
	}
	{{- else if and (eq .Type "array") (rootTypePath .Items.Type $.Content.RootTypes) }}
	for _, item := range c.{{ titleCase .Name }} {
		connections = append(connections, Connection{
			To: "{{ rootTypePath .Items.Type $.Content.RootTypes }}/" + item,
			Label: "{{ if .Label }}{{ .Label }}{{ else }}{{ titleCase .Name }}{{ end }}",
		})
	}
	{{- else if and (eq .Type "array") (eq .Items.Type "reference") }}
	for _, item := range c.{{ titleCase .Name }} {
		connections = append(connections, Connection{
			To: item.Path,
			Label: "{{ if .Label }}{{ .Label }}{{ else }}{{ titleCase .Name }}{{ end }}",
			Meta: "{{ .Meta }}",
		})
	}
	{{- else if eq .Meta "series" }}
	if c.{{ titleCase .Name }} != "" {
		connections = append(connections, Connection{
			To: c.{{ titleCase .Name }},
			Meta: "{{ .Meta }}",
		})
	}
	{{- end }}
	{{- end }}
	return connections
}
{{- range $key, $content := .Extra }}

type {{ titleCase $key }} struct {
{{- range $content.Properties }}
	{{ titleCase .Name }} {{ fieldType . $.Content.RootTypes }} `yaml:"{{ .Name }},omitempty" json:"{{ .Name }},omitempty"`
{{- end }}

	// unknown fields are stored in the Extra map
	Extra map[string]interface{} `yaml:",inline" json:",omitempty"`
}
{{- end }}

func length(a time.Duration) string {
	if a == 0 {
		return ""
	}

	if a < time.Hour {
		// format duration as "2m"
		return fmt.Sprintf("%dm", int(a.Minutes()))
	}

	// format duration as "1h 2m"
	return fmt.Sprintf("%dh %dm", int(a.Hours()), int(a.Minutes())%60)
}

func pathType(path string) string {
	return strings.Split(path, string(filepath.Separator))[0]
}

func removeFileExtention(path string) string {
	withoutExt := path[:len(path)-len(filepath.Ext(path))]
	if withoutExt != "" {
		return withoutExt
	}
	return path
}
